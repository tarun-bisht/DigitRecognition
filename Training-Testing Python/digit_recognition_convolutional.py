# -*- coding: utf-8 -*-
"""Digit Recognition Convolutional.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z2_F_kHL-lEcujUaaAA4bQWlu1FYkv0Y
"""

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
mnist=tf.keras.datasets.mnist
(x_train,y_train),(x_test,y_test)=mnist.load_data()

if tf.keras.backend.image_data_format() == 'channels_first':
    x_train = x_train.reshape(x_train.shape[0], 1, x_train.shape[1],x_train.shape[2])
    x_test = x_test.reshape(x_test.shape[0], 1, x_train.shape[1],x_train.shape[2])
    input_shape = (1, x_train.shape[1],x_train.shape[2])
else:
    x_train = x_train.reshape(x_train.shape[0], x_train.shape[1],x_train.shape[2], 1)
    x_test = x_test.reshape(x_test.shape[0], x_train.shape[1],x_train.shape[2], 1)
    input_shape = (x_train.shape[1],x_train.shape[2], 1)

for i in range(3):
    plt.imshow(x_train[i].reshape(28,28))
    plt.show()

x_train = x_train.astype('float32')
x_test = x_test.astype('float32')
x_train=x_train/255
x_test=x_test/255
y_train=tf.keras.utils.to_categorical(y_train,10)
y_test=tf.keras.utils.to_categorical(y_test,10)

model=tf.keras.models.Sequential()
##Hidden Layers with activation function RELU and size 16
model.add(tf.keras.layers.Conv2D(32,(5,5),input_shape=input_shape,activation=tf.nn.relu))
model.add(tf.keras.layers.MaxPooling2D(pool_size=(3, 3)))
model.add(tf.keras.layers.Conv2D(32,(2,2),activation=tf.nn.relu))
model.add(tf.keras.layers.MaxPooling2D(pool_size=(2, 2)))
model.add(tf.keras.layers.Dropout(0.2))
model.add(tf.keras.layers.Flatten())
model.add(tf.keras.layers.Dense(128,activation=tf.nn.relu))
##Output Layer with activation softmax and size 10 for 10 digits recognition
model.add(tf.keras.layers.Dense(10,activation=tf.nn.softmax))

model.compile(optimizer='adam',loss='categorical_crossentropy',metrics=['accuracy'])

model.fit(x_train,y_train,epochs=10)

val_loss,val_acc=model.evaluate(x_test,y_test)
print(val_loss)
print(val_acc)

prediction=model.predict(x_test)

##Showing Handwritten digit image with prediction
for i in range(10):
    plt.imshow(x_test[i].reshape(28,28))
    print(prediction[i])
    num=np.argmax(prediction[i])
    print(num)
    plt.show()

var=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.1843137254901961,0.12549019607843137,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.3137254901960784,1,1,1,0.6078431372549019,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.7294117647058823,1,1,1,1,0.43529411764705883,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.5843137254901961,1,1,1,1,0.9372549019607843,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0.7686274509803922,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0.996078431372549,1,1,1,1,1,0.8823529411764706,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0.09411764705882353,0,0,0,0,0,0.788235294117647,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0.5137254901960784,0,0,0,0,0,0,0,0.13725490196078433,1,1,0.9647058823529412,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0.9725490196078431,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0.6392156862745098,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0.7686274509803922,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0.807843137254902,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0.9333333333333333,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0.3058823529411765,0,0,0,1,1,1,0.9921568627450981,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.10588235294117647,1,1,1,1,1,0.9921568627450981,0.2823529411764706,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0.996078431372549,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

variable=np.array(var).reshape(1,28,28)
if tf.keras.backend.image_data_format() == 'channels_first':
    variable = variable.reshape(variable.shape[0], 1, variable.shape[1],variable.shape[2])
else:
    variable = variable.reshape(variable.shape[0], variable.shape[1],variable.shape[2], 1)
plt.imshow(variable.reshape(28,28),cmap='binary')
plt.show()
pred=model.predict(variable)
p=np.argmax(pred)
print(p)

# !pip3 install tensorflowjs 
# !mkdir model
# model.save('conv.h5')
# !ls
# !tensorflowjs_converter --input_format keras \conv.h5 \model
# !zip -r model.zip model 
# !ls -l
# from google.colab import files
# files.download('model.zip')

# !pip install -U -q PyDrive
# from pydrive.auth import GoogleAuth
# from pydrive.drive import GoogleDrive
# from google.colab import auth
# from oauth2client.client import GoogleCredentials

# # 1. Authenticate and create the PyDrive client.
# auth.authenticate_user()
# gauth = GoogleAuth()
# gauth.credentials = GoogleCredentials.get_application_default()
# drive = GoogleDrive(gauth)

# # 2. Save Keras Model or weights on google drive
# # create on Colab directory  
# model_str = drive.CreateFile({'title' : 'convDigitRecognition.json'})
# model_str.SetContentFile('convDigitRecognition.json')
# model_file = drive.CreateFile({'title' : 'convDigitRecognition.h5'})
# model_file.SetContentFile('convDigitRecognition.h5')
# model_file.Upload()
# model_str.Upload()

# # download to google drive
# drive.CreateFile({'m_id': model_file.get('id'),'j_id': model_str.get('id')})